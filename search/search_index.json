{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Convert2RHEL Notes","text":"<p>Notes for my development in Convert2RHEL</p>"},{"location":"#research","title":"Research","text":"<ul> <li>Package Manager Architecture - Introduction</li> </ul>"},{"location":"#rhelc-jira-tasks","title":"RHELC (Jira tasks)","text":"<ul> <li>RHELC-889</li> </ul>"},{"location":"RHELC/RHELC-889/","title":"shim-x64 package being downgraded","text":"<p>Jira ticket: https://issues.redhat.com/browse/RHELC-899</p> <p>GitHub Pull Request: https://github.com/oamg/convert2rhel/pull/833</p>"},{"location":"RHELC/RHELC-889/#important-notes","title":"Important notes","text":"<ul> <li>This problem happens only on UEFI machines.<ul> <li>Later in the investigation, we verified that it happens on UEFI and BIOS.</li> </ul> </li> <li>It affects both RHEL 7 and RHEL 8</li> </ul>"},{"location":"RHELC/RHELC-889/#introduction","title":"Introduction","text":"<p>From my understanding of the problem related in that ticket, it seems that after we finish the conversion (which, apparently, doesn't error out anywhere) the package shim-x64 is in an older version than it is supposed to be.</p> <p>It is strange that the package starts in one version and ends-up in a lower one after the conversion finishes.</p> <p>For Oracle Linux 7.9 we have set this package to be in the list for removal during the conversion. Not exactly sure on why we did that in the past, but it is know that the package caused problems during the transaction validation (both the old one and the new one).</p> <p>Looking at the workflow that we go inside our transaction handler, it seems that the shim-x64 package is trying to:</p> <ol> <li>Update the package (which doesn't error out)</li> <li>Reinstall the package (Here it fails)</li> <li>Then it downgrades the package to the lower version</li> </ol> <p>I wonder if we actually need to try to reinstall the package even if we can update it.</p>"},{"location":"RHELC/RHELC-889/#rhel-7-centos-79","title":"RHEL 7 (CentOS 7.9)","text":"<ul> <li>Package version on a fresh machine: <code>shim-x64-15-8.el7.x86_64</code>.</li> <li>Package version after conversion: <code>shim-x64-15-7.el7_8.x86_64</code> and it seems to be the only one installed on the system. This version is lightly different from the one in the ticket as the date for this package in the rhel-7-server-rpms repos is <code>2023-04-18 07:16</code>.</li> </ul>"},{"location":"RHELC/RHELC-889/#rhel-8-centos-85","title":"RHEL 8 (CentOS 8.5)","text":"<ul> <li>Package version on a fresh machine: <code>shim-x64-15-15.el8_2.x86_64</code></li> <li>Package version after conversion: <code>shim-x64-15-15.el8_2.x86_64</code> (reinstallation)</li> </ul>"},{"location":"RHELC/RHELC-889/#notes-for-05182023","title":"Notes for 05/18/2023","text":"<p>After speaking with Michal Bocek, we confirmed that the correct behavior for the transaction validation/replacement is that we only should proceed on the reinstall of a package only if the package update will not work out, meaning that if a package is marked for update, then we don't need to do anything else.</p> <p>After that conversation, I adjusted the code for the Yum transaction handler to apply that concept and it seems that not only the shim-x64 package is updated properly, but a lot of other packages that were suffering from the same condition. In the end, we were not only causing problems with that specific package, but with others as well, which were being reinstalled and downgraded.</p> <p>I'm still waiting for some reply from the DNF team to make sure that I can do the same approach for Yum in DNF as well, as it will suffers from the same problem, but this time, not related to downgrade, but it is related to the reinstall process, as the DNF API is reinstalling the package with the same version.</p>"},{"location":"RHELC/RHELC-889/#notes-for-05192023","title":"Notes for 05/19/2023","text":"<p>After more talking and investigation with the DNF team, we were able to come up with a simple solution that relies on querying the upgradable packages on the system, and then, checking if that package can be upgraded or not. If the package is not able to be upgradable, then we do down the route for reinstall/downgrade. This strategy is very similar to the one done in YUM, with the only difference that in YUM, we already have a sentinel value to check in the code, and for DNF, we need to query it first to check if the package can be upgaded.</p>"},{"location":"RHELC/RHELC-889/#conclusion","title":"Conclusion","text":"<p>We had an incorrect behavior regarding the way we treat the packages that we pass down to the transaction validation/replacement. The operations we execute in this steps are the following:</p> <ol> <li>Update the packages installed on the system</li> <li>Reinstall the pakcages installed on the system</li> <li>Downgrade the packages installed on the system</li> </ol> <p>The last two operations should only be executed if the package can't be updated, for any reason. Think of it like a cascade, if the <code>1</code> operation \"fails\", then we go to the <code>2</code>, if that fails, then <code>3</code>.</p>"},{"location":"RHELC/RHELC-889/#todo-list","title":"Todo List","text":"<ol> <li> Check if the reproducer is valid</li> <li> Test if the <code>yum update shim-x64</code> really tries to update the package</li> </ol> <p>It does seem that we are either reinstalling the package to an older version, or, dowgrading the package.</p>"},{"location":"RHELC/RHELC-889/#todo-list-for-yum-debugging","title":"Todo list for yum debugging","text":"<ol> <li> Debug the path we go through the yum library to see if the package can't be updated (and the reason for that)</li> </ol>"},{"location":"Research/Package%20Manager%20Architecture/Architecture/","title":"Architecture","text":""},{"location":"Research/Package%20Manager%20Architecture/Architecture/#basepackagemanager","title":"BasePackageManager","text":"<pre><code>classDiagram\nBasePackageManager --|&gt; Yum\nBasePackageManager --|&gt; Dnf\n\nBasePackageManager : get_installed_packages()\nBasePackageManager : install()\nBasePackageManager : upgrade()\nBasePackageManager : downgrade()\nBasePackageManager : reinstall()\n</code></pre>"},{"location":"Research/Package%20Manager%20Architecture/Introduction/","title":"Introduction","text":"<p>The pkgmanager module is currently used, primarily as a top-level import, to determinate which package manager is being used, depending on the import and version. </p> <p>This causes some circular dependency imports from time to time, as we want to take this module further and improve it to allow more customization and more, eventually, aggregate all things related to package managers in this module. </p>"},{"location":"Research/Package%20Manager%20Architecture/Introduction/#what-to-expected-that-will-be-in-this-module","title":"What to expected that will be in this module?","text":"<p>Currently, we are aiming to provide capabilities for YUM, DNF and RPM. Each of those package managers will have its own module that will interact with either the Python API, or the CLI call that will correspond with the desired package manager.</p> <p>The YUM/DNF classes that will be described below, will have one thing in common. They will be part of a base class that will dictate how they should operate, what methods to implement, and what needs to be followed to whoever needs to implement a new package manager.</p>"},{"location":"Research/Package%20Manager%20Architecture/Introduction/#yum","title":"YUM","text":"<p>The YUM class will implement all of the Python API used under the hood for Convert2RHEL, we will aim here at gathering all the common operations used here and implemented under this class. One can expect that we will deal and treat all basic operations thorugh here, like, look if a package is installed, installing a package, removing package, determinating if the base class needs to exist or not and so on...</p> <p>We could think about this class being very similar to yum transaction handler. </p>"},{"location":"Research/Package%20Manager%20Architecture/Introduction/#dnf","title":"DNF","text":"<p>The DNF class will be very similar to the YUM one, as we have the same intention to maintain a sane interface between the two. </p> <p>There is no much to add here since they will be very similar, the only thing that will change is that we will use the DNF Python API instead.</p>"},{"location":"Research/Package%20Manager%20Architecture/Introduction/#rpm","title":"RPM","text":"<p>The RPM module may be the easiest module to convert, as it consist mostly of binary calls to the RPM binary present on the system. The difficult part will be integrating this class with DNF and YUM classes, as this one will be very different from the rest. </p> <p>Since the YUM/DNF classes will operate mostly on Python API bindings, and not so much on CLI calls, we can expect a few differences here, and they might not be fully compatible. </p>"},{"location":"Research/Package%20Manager%20Architecture/Random%20Notes/","title":"Random Notes","text":""},{"location":"Research/Package%20Manager%20Architecture/Random%20Notes/#notes-from-05222023","title":"Notes from 05/22/2023","text":"<p>We probably can move away a few functions from pkghandler.py to live inside specific modules after this refactor. </p> <p>For example, the get_system_packages_for_replacement, is a function that is used only for DNF and YUM in transaction handler mode. </p> <p>Probably would be better to start making a list of things that can be moved to the new module and removed from pkghandler.</p> <p>Probably it would be better to think in a way that minimize all of this changes to the tool, otherwise, it would take super long to make this viable. </p> <p>We could use the Tech Preview feature to start introducing changes in a first release, just to get the hang of it, probably behind a flag so the user has to explicitly ask for it. </p> <p>If we decide that releasing this as a Tech Preview is the easiest way for now, I wonder if we could maintain the same code running as we have right now, but only execute the new one if the flag is used.  Of course, changes would be needed to do this, but they would \"be minimal\", for now... </p> <p>Taking as an example the transaction handler, that would be a very comfortable way of introducing this first piece of change, as we don't have any return value for this operation and we could very easily toggle between on and off for that feature.</p> <p>Other places on the system that would benefit from that refactor still needs to be investigated and select, but for now, transaction handler is a big candidate.</p>"},{"location":"Research/Package%20Manager%20Architecture/To%20do/","title":"To do","text":""},{"location":"Research/Package%20Manager%20Architecture/To%20do/#moving-things-away-from-pkghandler","title":"Moving things away from pkghandler","text":"<ul> <li> <code>get_system_packages_for_replacement</code></li> <li> <code>get_installed_pkg_information</code> Could be moved to be in the RPM class</li> <li> <code>get_installed_pkg_objects</code> </li> <li> <code>call_yum_cmd</code> Is a special one... Maybe we could place it in a <code>utils.py</code> for pkgmanager</li> <li> <code>get_rpm_header</code> could probably live inside a RPM class as it is very specific</li> </ul>"}]}